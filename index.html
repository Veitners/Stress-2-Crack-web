<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FEM Reader Web - Static Version</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        
        .row {
            margin: 0 !important;
        }
        
        .container-fluid { 
            padding: 10px !important; 
            height: 100vh; 
            display: flex; 
            flex-direction: column;
            max-width: 100% !important;
        }
        .control-panel { background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        .plot-container { 
            border: 1px solid #dee2e6; 
            border-radius: 8px; 
            padding: 10px; 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            min-height: 0;
            height: 100%;
        }
        .stats-card { background-color: #e3f2fd; padding: 15px; border-radius: 8px; margin: 10px 0; }
        .file-upload-area { 
            border: 2px dashed #007bff; 
            border-radius: 8px; 
            padding: 40px; 
            text-align: center; 
            background-color: #f8f9fa;
            transition: background-color 0.3s;
        }
        .file-upload-area:hover { background-color: #e9ecef; }
        .parameter-group { margin: 15px 0; }
        .threshold-inputs, .output-inputs { display: flex; gap: 10px; }
        .threshold-inputs input, .output-inputs input { flex: 1; }
        #loadingSpinner { display: none; }
        .github-link { position: fixed; top: 10px; right: 10px; }
        .main-row { 
            flex: 1; 
            min-height: 0; 
            height: 100%; 
            display: flex !important;
            flex-wrap: nowrap !important;
        }
        .sidebar-col { 
            overflow-y: auto; 
            max-height: calc(100vh - 100px);
            flex: 0 0 300px !important;
            max-width: 300px !important;
            min-width: 300px;
            margin-right: 10px;
        }
        .plot-col { 
            display: flex; 
            flex-direction: column; 
            min-height: 0;
            flex: 1 !important;
            height: 100%;
            width: calc(100% - 310px) !important;
        }
        
        /* Ensure plot divs take full space */
        #mainPlot, #curveContainer {
            width: 100% !important;
            height: 100% !important;
            min-height: 500px;
        }
        
        #plotArea, #curvePlot {
            flex: 1 !important;
            min-height: 0 !important;
            height: 100% !important;
        }

        /* Responsive adjustments */
        @media (max-width: 992px) {
            .sidebar-col {
                flex: 0 0 280px !important;
                max-width: 280px !important;
                min-width: 280px;
            }
            .plot-col {
                width: calc(100% - 280px) !important;
            }
        }
        
        @media (max-width: 768px) {
            .container-fluid { padding: 5px; }
            .control-panel { padding: 10px; margin-bottom: 10px; }
            .plot-container { padding: 5px; }
            .sidebar-col { 
                flex: 0 0 250px !important;
                max-width: 250px !important;
                min-width: 250px;
                max-height: calc(100vh - 80px);
            }
            .plot-col { 
                width: calc(100% - 250px) !important;
                min-height: 400px; 
            }
            .threshold-inputs, .output-inputs { flex-direction: column; gap: 5px; }
            #mainPlot, #curveContainer {
                min-height: 400px;
            }
        }
        
        /* Only stack vertically on very small screens */
        @media (max-width: 576px) {
            .main-row { 
                flex-direction: column !important; 
                flex-wrap: wrap !important;
            }
            .sidebar-col { 
                flex: none !important;
                max-width: 100% !important;
                min-width: auto !important;
                width: 100% !important;
                max-height: 300px;
                margin-bottom: 10px;
            }
            .plot-col {
                width: 100% !important;
                flex: 1 !important;
            }
        }
        
        @media (max-width: 576px) {
            .container-fluid { padding: 5px; }
            .control-panel { padding: 10px; }
            .plot-container { padding: 10px; }
            .btn-group { flex-direction: column; }
            .btn-group .btn { margin-bottom: 5px; }
        }
    </style>
</head>
<body>
    <!-- GitHub Link -->
    <a href="https://github.com/yourusername/fem-reader-web" class="github-link btn btn-dark btn-sm" target="_blank">
        <i class="fab fa-github"></i> View on GitHub
    </a>

    <div class="container-fluid">
        <!-- Header -->
        <div class="row">
            <div class="col-12">
                <h1 class="text-center mb-4">üîß FEM Reader Web - Static Version</h1>
                <p class="text-center text-muted">Professional structural analysis visualization tool for FEM data (Client-side processing)</p>
            </div>
        </div>

        <!-- Main Content -->
        <div class="row main-row g-0">
            <!-- Left Sidebar - Controls -->
            <div class="sidebar-col">
                <div class="control-panel">
                    <!-- File Upload -->
                    <h5>üìÅ File Upload</h5>
                    <div class="file-upload-area" id="fileUploadArea">
                        <input type="file" id="fileInput" accept=".xlsx" class="form-control" style="display: none;">
                        <div id="uploadPrompt">
                            <i class="fas fa-cloud-upload-alt fa-3x text-primary mb-3"></i>
                            <p>Click here to select your Excel file</p>
                            <small class="text-muted">Supports .xlsx files (processed locally in your browser)</small>
                        </div>
                        <div id="uploadStatus" style="display: none;"></div>
                    </div>

                    <!-- Column Selection -->
                    <div id="columnSelection" style="display: none;" class="mt-4">
                        <h6>üìä Visualization</h6>
                        <label for="columnSelect">Select data column:</label>
                        <select id="columnSelect" class="form-select mb-3"></select>
                        
                        <div class="btn-group d-flex mb-2" role="group">
                            <input type="radio" class="btn-check" name="viewMode" id="view2D" value="2D">
                            <label class="btn btn-outline-primary" for="view2D">2D</label>
                            
                            <input type="radio" class="btn-check" name="viewMode" id="view3D" value="3D" checked>
                            <label class="btn btn-outline-primary" for="view3D">3D</label>
                        </div>

                        <div class="form-check mb-3">
                            <input class="form-check-input" type="checkbox" id="heatmapMode" checked>
                            <label class="form-check-label" for="heatmapMode">Heatmap/Surface Mode</label>
                        </div>

                        <div class="alert alert-info py-2 px-3 mb-3" style="font-size: 12px;">
                            <strong>2D Controls:</strong><br>
                            ‚Ä¢ Mouse wheel: Zoom in/out<br>
                            ‚Ä¢ Click + drag: Pan around<br>
                            ‚Ä¢ Double-click: Reset zoom<br>
                            ‚Ä¢ Points auto-scale with zoom
                        </div>

                        <label for="colorMapSelect">Color Map:</label>
                        <select id="colorMapSelect" class="form-select mb-3">
                            <option value="Viridis">Viridis</option>
                            <option value="Plasma">Plasma</option>
                            <option value="Jet">Jet</option>
                            <option value="RdYlBu">RdYlBu</option>
                            <option value="Blues">Blues</option>
                        </select>
                    </div>

                    <!-- Deformation Parameters -->
                    <div id="deformationParams" style="display: none;" class="mt-4">
                        <h6>‚öôÔ∏è Deformation Parameters</h6>
                        
                        <div class="parameter-group">
                            <label>Thresholds (œÉ_CMOD):</label>
                            <div class="threshold-inputs">
                                <input type="number" id="threshold1" value="0.000061" step="0.000001" class="form-control form-control-sm" placeholder="œÉ_CMOD0">
                                <input type="number" id="threshold2" value="0.000161" step="0.000001" class="form-control form-control-sm" placeholder="œÉ_CMOD1">
                                <input type="number" id="threshold3" value="0.003967" step="0.000001" class="form-control form-control-sm" placeholder="œÉ_CMOD3">
                            </div>
                        </div>

                        <div class="parameter-group">
                            <label>Outputs (CMOD):</label>
                            <div class="output-inputs">
                                <input type="number" id="output1" value="0.0" step="0.1" class="form-control form-control-sm" placeholder="CMOD 0">
                                <input type="number" id="output2" value="0.5" step="0.1" class="form-control form-control-sm" placeholder="CMOD 1">
                                <input type="number" id="output3" value="2.5" step="0.1" class="form-control form-control-sm" placeholder="CMOD 3">
                            </div>
                        </div>

                        <button id="applyChanges" class="btn btn-primary btn-sm me-2">Apply Changes</button>
                        <button id="previewCurve" class="btn btn-success btn-sm">Preview Curve</button>
                        <button id="resetParams" class="btn btn-secondary btn-sm mt-2">Reset Defaults</button>
                    </div>

                    <!-- Export -->
                    <div id="exportSection" style="display: none;" class="mt-4">
                        <h6>üíæ Export</h6>
                        <button id="exportData" class="btn btn-info btn-sm">Export Data</button>
                    </div>
                </div>

                <!-- Statistics -->
                <div id="statisticsPanel" style="display: none;" class="stats-card">
                    <h6>üìà Statistics</h6>
                    <div id="statsContent"></div>
                </div>

                <!-- Info Panel -->
                <div class="stats-card">
                    <h6>‚ÑπÔ∏è About</h6>
                    <small>
                        This is a client-side web version of FEM Reader. All processing happens in your browser - no data is sent to servers.
                    </small>
                </div>
            </div>

            <!-- Right Side - Plot Area -->
            <div class="plot-col">
                <div class="plot-container">
                    <div id="loadingSpinner" class="text-center">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Processing...</span>
                        </div>
                        <p class="mt-2">Processing data in browser...</p>
                    </div>
                    
                    <div id="plotArea" style="display: none; flex: 1; min-height: 0;">
                        <div id="mainPlot" style="width: 100%; height: 100%;"></div>
                    </div>

                    <div id="curvePlot" style="display: none; flex: 1; min-height: 0;">
                        <div id="curveContainer" style="width: 100%; height: 100%;"></div>
                    </div>

                    <div id="welcomeMessage" class="text-center text-muted" style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                        <i class="fas fa-chart-line fa-4x mb-3"></i>
                        <h4>Welcome to FEM Reader Web</h4>
                        <p>Upload an Excel file to begin visualization</p>
                        <small>All processing happens locally in your browser</small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Font Awesome for icons -->
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>

    <script>
        let currentData = null;
        let currentHeaders = [];
        let processedData = null;
        let currentPlotData = null;
        let currentLayout = null;
        let resizeTimeout = null;
        let zoomState = { xRange: null, yRange: null, baseSize: 4 };

        // Dynamic point sizing for 2D plots
        function setupDynamicPointSizing(x, y, values, selectedColumn, colorMap) {
            const plotDiv = document.getElementById('mainPlot');
            
            // Calculate initial point density and size
            const dataRange = {
                x: Math.max(...x) - Math.min(...x),
                y: Math.max(...y) - Math.min(...y)
            };
            
            // Estimate average distance between nearest neighbors
            const numPoints = x.length;
            const plotArea = dataRange.x * dataRange.y;
            
            // Calculate approximate grid spacing if points were evenly distributed
            const approxSpacing = Math.sqrt(plotArea / numPoints);
            
            // Size points to be 1.5x the spacing to ensure overlap
            zoomState.baseSize = Math.max(10, Math.min(80, approxSpacing * 200));
            
            // Store initial axis ranges for zoom calculation
            const layout = plotDiv.layout;
            if (layout && layout.xaxis && layout.yaxis) {
                zoomState.xRange = layout.xaxis.range || [Math.min(...x), Math.max(...x)];
                zoomState.yRange = layout.yaxis.range || [Math.min(...y), Math.max(...y)];
            }
            
            // Add event listener for zoom/pan events
            plotDiv.on('plotly_relayout', function(eventData) {
                if (eventData['xaxis.range[0]'] !== undefined || eventData['xaxis.range[1]'] !== undefined ||
                    eventData['yaxis.range[0]'] !== undefined || eventData['yaxis.range[1]'] !== undefined) {
                    
                    // Get current zoom ranges
                    const currentXRange = [
                        eventData['xaxis.range[0]'] !== undefined ? eventData['xaxis.range[0]'] : zoomState.xRange[0],
                        eventData['xaxis.range[1]'] !== undefined ? eventData['xaxis.range[1]'] : zoomState.xRange[1]
                    ];
                    
                    const currentYRange = [
                        eventData['yaxis.range[0]'] !== undefined ? eventData['yaxis.range[0]'] : zoomState.yRange[0],
                        eventData['yaxis.range[1]'] !== undefined ? eventData['yaxis.range[1]'] : zoomState.yRange[1]
                    ];
                    
                    // Calculate zoom factor
                    const currentXSpan = currentXRange[1] - currentXRange[0];
                    const currentYSpan = currentYRange[1] - currentYRange[0];
                    const originalXSpan = dataRange.x;
                    const originalYSpan = dataRange.y;
                    
                    const zoomFactorX = originalXSpan / currentXSpan;
                    const zoomFactorY = originalYSpan / currentYSpan;
                    const avgZoomFactor = Math.sqrt(zoomFactorX * zoomFactorY);
                    
                    // Calculate new point size (increase more aggressively with zoom)
                    let newSize = zoomState.baseSize * Math.pow(avgZoomFactor, 0.8);
                    
                    // Clamp size to reasonable bounds - allow larger sizes
                    newSize = Math.max(5, Math.min(newSize, 200));
                    
                    // Update point sizes
                    const update = {
                        'marker.size': Array(x.length).fill(newSize)
                    };
                    
                    Plotly.restyle('mainPlot', update, 0);
                    
                    // Store current ranges
                    zoomState.xRange = currentXRange;
                    zoomState.yRange = currentYRange;
                }
            });
        }

        // Deformation modification function
        function modifyDeformation(value, threshold1, threshold2, threshold3, output1, output2, output3) {
            value = value / 1000;
            if (value < threshold1) {
                return output1;
            } else if (value <= threshold2) {
                return output1 + (output2 - output1) * (value - threshold1) / (threshold2 - threshold1);
            } else if (value <= threshold3) {
                return output2 + (output3 - output2) * (value - threshold2) / (threshold3 - threshold2);
            } else {
                // Linear extrapolation beyond threshold3
                const slope = (output3 - output2) / (threshold3 - threshold2);
                return output3 + slope * (value - threshold3);
            }
        }

        // File upload handling
        document.getElementById('fileUploadArea').addEventListener('click', function() {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                uploadFile(file);
            }
        });

        function uploadFile(file) {
            document.getElementById('uploadPrompt').style.display = 'none';
            document.getElementById('uploadStatus').innerHTML = '<div class="spinner-border spinner-border-sm me-2"></div>Processing...';
            document.getElementById('uploadStatus').style.display = 'block';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    processExcelFile(workbook);
                } catch (error) {
                    document.getElementById('uploadStatus').innerHTML = `<div class="text-danger">‚ùå Error reading file: ${error.message}</div>`;
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function processExcelFile(workbook) {
            try {
                const allData = [];
                const allHeaders = [];

                workbook.SheetNames.forEach(sheetName => {
                    const sheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                    
                    if (jsonData.length < 3) return; // Need at least header and some data
                    
                    // Skip first row (title), use second row as headers
                    const headers = jsonData[1];
                    const dataRows = jsonData.slice(2);
                    
                    if (headers.length < 5) return; // Need at least Point, X, Y, Z, and one data column
                    
                    // Process each data row
                    const processedRows = [];
                    dataRows.forEach(row => {
                        if (row.length >= 5 && row[1] != null && row[2] != null && row[3] != null && row[4] != null) {
                            const processedRow = {
                                Point: row[1],
                                X: parseFloat(row[2]),
                                Y: parseFloat(row[3]),
                                Z: parseFloat(row[4])
                            };
                            
                            // Add data columns (from index 5 onwards)
                            for (let i = 5; i < headers.length && i < row.length; i++) {
                                if (headers[i] && row[i] != null) {
                                    const colName = `${sheetName} - ${headers[i]}`;
                                    processedRow[colName] = parseFloat(row[i]);
                                    if (!allHeaders.includes(colName)) {
                                        allHeaders.push(colName);
                                    }
                                }
                            }
                            
                            // Only add if we have all required coordinates
                            if (!isNaN(processedRow.X) && !isNaN(processedRow.Y) && !isNaN(processedRow.Z)) {
                                processedRows.push(processedRow);
                            }
                        }
                    });
                    
                    allData.push(...processedRows);
                });

                if (allData.length === 0 || allHeaders.length === 0) {
                    throw new Error("No valid data found in Excel file");
                }

                currentData = allData;
                currentHeaders = allHeaders;

                document.getElementById('uploadStatus').innerHTML = `<div class="text-success">‚úÖ File processed: ${allData.length} points, ${allHeaders.length} data columns</div>`;
                
                populateColumnSelect(allHeaders);
                showControls();
                document.getElementById('welcomeMessage').style.display = 'none';

            } catch (error) {
                document.getElementById('uploadStatus').innerHTML = `<div class="text-danger">‚ùå Error processing file: ${error.message}</div>`;
            }
        }

        function populateColumnSelect(headers) {
            const select = document.getElementById('columnSelect');
            select.innerHTML = '';
            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                select.appendChild(option);
            });
            if (headers.length > 0) {
                select.value = headers[0];
            }
        }

        function showControls() {
            document.getElementById('columnSelection').style.display = 'block';
            document.getElementById('deformationParams').style.display = 'block';
            document.getElementById('exportSection').style.display = 'block';
            generatePlot();
        }

        function generatePlot() {
            if (!currentData || currentHeaders.length === 0) return;

            const selectedColumn = document.getElementById('columnSelect').value;
            const viewMode = document.querySelector('input[name="viewMode"]:checked').value;
            const heatmapMode = document.getElementById('heatmapMode').checked;
            const colorMap = document.getElementById('colorMapSelect').value;

            // Get deformation parameters
            const threshold1 = parseFloat(document.getElementById('threshold1').value);
            const threshold2 = parseFloat(document.getElementById('threshold2').value);
            const threshold3 = parseFloat(document.getElementById('threshold3').value);
            const output1 = parseFloat(document.getElementById('output1').value);
            const output2 = parseFloat(document.getElementById('output2').value);
            const output3 = parseFloat(document.getElementById('output3').value);

            // Validate thresholds
            if (threshold1 >= threshold2 || threshold2 >= threshold3) {
                alert('Thresholds must be in ascending order!');
                return;
            }

            document.getElementById('loadingSpinner').style.display = 'block';
            document.getElementById('plotArea').style.display = 'none';
            document.getElementById('curvePlot').style.display = 'none';

            // Process data with a small delay to allow UI update
            setTimeout(() => {
                try {
                    // Extract coordinates and values
                    const x = [];
                    const y = [];
                    const z = [];
                    const values = [];

                    currentData.forEach(row => {
                        if (row[selectedColumn] != null) {
                            x.push(row.X);
                            y.push(-row.Y);
                            z.push(row.Z);  // Flip Z coordinate by negating it
                            
                            // Apply deformation modification
                            const modifiedValue = modifyDeformation(
                                row[selectedColumn], 
                                threshold1, threshold2, threshold3, 
                                output1, output2, output3
                            );
                            values.push(modifiedValue);
                        }
                    });

                    if (x.length === 0) {
                        throw new Error('No valid data for selected column');
                    }

                    // Create plot
                    let plotData, layout;

                    if (viewMode === '3D') {
                        if (heatmapMode) {
                            // Try to create a surface plot (simplified)
                            plotData = [{
                                type: 'scatter3d',
                                mode: 'markers',
                                x: x,
                                y: y,
                                z: z,
                                marker: {
                                    size: 3,
                                    color: values,
                                    colorscale: colorMap,
                                    showscale: true,
                                    colorbar: { title: `${selectedColumn} (mm)` }
                                }
                            }];
                        } else {
                            plotData = [{
                                type: 'scatter3d',
                                mode: 'markers',
                                x: x,
                                y: y,
                                z: z,
                                marker: {
                                    size: 3,
                                    color: values,
                                    colorscale: colorMap,
                                    showscale: true,
                                    colorbar: { title: `${selectedColumn} (mm)` }
                                }
                            }];
                        }

                        layout = {
                            title: {
                                text: `3D Visualization - ${selectedColumn}`,
                                x: 0.5,
                                font: { size: 16 }
                            },
                            scene: {
                                xaxis: { title: 'X Coordinate' },
                                yaxis: { title: 'Y Coordinate' },
                                zaxis: { title: 'Z Coordinate' }
                            },
                            margin: { l: 0, r: 0, t: 50, b: 0 },
                            autosize: true,
                            height: null,
                            width: null
                        };
                    } else {
                        // 2D plot - calculate initial size based on point spacing
                        const dataRange = {
                            x: Math.max(...x) - Math.min(...x),
                            y: Math.max(...y) - Math.min(...y)
                        };
                        const plotArea = dataRange.x * dataRange.y;
                        const approxSpacing = Math.sqrt(plotArea / x.length);
                        const initialSize = Math.max(10, Math.min(80, approxSpacing * 200));
                        
                        plotData = [{
                            type: 'scatter',
                            mode: 'markers',
                            x: x,
                            y: y,
                            marker: {
                                size: initialSize,
                                color: values,
                                colorscale: colorMap,
                                showscale: true,
                                colorbar: { title: `${selectedColumn} (mm)` },
                                opacity: 0.8,
                                line: { width: 0 }
                            }
                        }];

                        layout = {
                            title: {
                                text: `2D Visualization - ${selectedColumn}`,
                                x: 0.5,
                                font: { size: 16 }
                            },
                            xaxis: { 
                                title: 'X Coordinate',
                                showspikes: true,
                                spikemode: 'across',
                                spikesnap: 'cursor'
                            },
                            yaxis: { 
                                title: 'Y Coordinate', 
                                scaleanchor: 'x',
                                showspikes: true,
                                spikemode: 'across',
                                spikesnap: 'cursor'
                            },
                            margin: { l: 50, r: 20, t: 50, b: 50 },
                            autosize: true,
                            height: null,
                            width: null,
                            dragmode: 'zoom',
                            hovermode: 'closest'
                        };
                    }

                    // Store current plot data and layout for resizing
                    currentPlotData = plotData;
                    currentLayout = layout;

                    // Create plot with responsive configuration and enable scroll zoom
                    const config = {
                        responsive: true,
                        scrollZoom: viewMode === '2D', // Enable scroll zoom only for 2D plots
                        doubleClick: 'reset', // Double click to reset zoom
                        displayModeBar: true,
                        modeBarButtonsToAdd: ['pan2d', 'zoom2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d']
                    };

                    Plotly.newPlot('mainPlot', plotData, layout, config);

                    // Add dynamic point sizing for 2D plots
                    if (viewMode === '2D') {
                        setupDynamicPointSizing(x, y, values, selectedColumn, colorMap);
                    }
                    
                    document.getElementById('loadingSpinner').style.display = 'none';
                    document.getElementById('plotArea').style.display = 'block';

                    // Ensure plot is properly sized after container becomes visible
                    setTimeout(function() {
                        Plotly.Plots.resize('mainPlot');
                    }, 50);

                    // Update statistics
                    const stats = {
                        min: Math.min(...values),
                        max: Math.max(...values),
                        mean: values.reduce((a, b) => a + b, 0) / values.length,
                        std: Math.sqrt(values.reduce((a, b) => a + Math.pow(b - values.reduce((c, d) => c + d, 0) / values.length, 2), 0) / values.length)
                    };
                    updateStatistics(stats);

                } catch (error) {
                    document.getElementById('loadingSpinner').style.display = 'none';
                    alert(`Error generating plot: ${error.message}`);
                }
            }, 100);
        }

        function updateStatistics(stats) {
            const statsContent = document.getElementById('statsContent');
            statsContent.innerHTML = `
                <small>
                    <strong>Points:</strong> ${currentData.length}<br>
                    <strong>Min:</strong> ${stats.min.toFixed(3)}<br>
                    <strong>Max:</strong> ${stats.max.toFixed(3)}<br>
                    <strong>Mean:</strong> ${stats.mean.toFixed(3)}<br>
                    <strong>Std:</strong> ${stats.std.toFixed(3)}
                </small>
            `;
            document.getElementById('statisticsPanel').style.display = 'block';
        }

        function previewCurve() {
            const threshold1 = parseFloat(document.getElementById('threshold1').value);
            const threshold2 = parseFloat(document.getElementById('threshold2').value);
            const threshold3 = parseFloat(document.getElementById('threshold3').value);
            const output1 = parseFloat(document.getElementById('output1').value);
            const output2 = parseFloat(document.getElementById('output2').value);
            const output3 = parseFloat(document.getElementById('output3').value);

            // Generate curve data
            const xVals = [];
            const yVals = [];
            const maxX = threshold3 * 2;
            for (let i = 0; i <= 1000; i++) {
                const x = (i / 1000) * maxX * 1000; // Convert back to original scale
                const y = modifyDeformation(x, threshold1, threshold2, threshold3, output1, output2, output3);
                xVals.push(x / 1000); // Convert for display
                yVals.push(y);
            }

            const plotData = [
                {
                    type: 'scatter',
                    mode: 'lines',
                    x: xVals,
                    y: yVals,
                    name: 'Deformation Curve',
                    line: { width: 2 }
                },
                {
                    type: 'scatter',
                    mode: 'markers',
                    x: [threshold1, threshold2, threshold3],
                    y: [output1, output2, output3],
                    name: 'Threshold Points',
                    marker: { size: 10, color: 'red' }
                }
            ];

            const layout = {
                title: {
                    text: 'Deformation ‚Üí CMOD Modification Function',
                    x: 0.5,
                    font: { size: 16 }
                },
                xaxis: { title: 'Input Value (after /1000)' },
                yaxis: { title: 'CMOD Output Value' },
                showlegend: true,
                margin: { l: 50, r: 20, t: 50, b: 50 },
                autosize: true,
                height: null,
                width: null
            };

            Plotly.newPlot('curveContainer', plotData, layout, {responsive: true});
            document.getElementById('plotArea').style.display = 'none';
            document.getElementById('curvePlot').style.display = 'block';
            
            // Ensure curve plot is properly sized after becoming visible
            setTimeout(function() {
                Plotly.Plots.resize('curveContainer');
            }, 50);
        }

        function resetParameters() {
            document.getElementById('threshold1').value = '0.000061';
            document.getElementById('threshold2').value = '0.000161';
            document.getElementById('threshold3').value = '0.003967';
            document.getElementById('output1').value = '0.0';
            document.getElementById('output2').value = '0.5';
            document.getElementById('output3').value = '2.5';
            generatePlot();
        }

        function exportData() {
            if (!currentData || currentHeaders.length === 0) return;

            const selectedColumn = document.getElementById('columnSelect').value;
            
            // Create export data
            const exportData = currentData.map(row => ({
                Point: row.Point,
                X: row.X,
                Y: row.Y,
                Z: row.Z,
                [selectedColumn]: row[selectedColumn]
            })).filter(row => row[selectedColumn] != null);

            // Convert to worksheet
            const ws = XLSX.utils.json_to_sheet(exportData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Processed_Data");

            // Save file
            XLSX.writeFile(wb, "fem_processed_data.xlsx");
        }

        // Event listeners
        document.getElementById('columnSelect').addEventListener('change', generatePlot);
        document.querySelector('input[name="viewMode"][value="2D"]').addEventListener('change', generatePlot);
        document.querySelector('input[name="viewMode"][value="3D"]').addEventListener('change', generatePlot);
        document.getElementById('heatmapMode').addEventListener('change', generatePlot);
        document.getElementById('colorMapSelect').addEventListener('change', generatePlot);
        document.getElementById('applyChanges').addEventListener('click', generatePlot);
        document.getElementById('previewCurve').addEventListener('click', previewCurve);
        document.getElementById('resetParams').addEventListener('click', resetParameters);
        document.getElementById('exportData').addEventListener('click', exportData);

        // Back to main plot when viewing curve
        document.getElementById('curveContainer').addEventListener('dblclick', function() {
            document.getElementById('curvePlot').style.display = 'none';
            document.getElementById('plotArea').style.display = 'block';
        });

        // Window resize handling for responsive plots
        function handleResize() {
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            
            resizeTimeout = setTimeout(function() {
                // Resize main plot if visible
                if (document.getElementById('plotArea').style.display !== 'none' && 
                    document.getElementById('mainPlot').children.length > 0) {
                    Plotly.Plots.resize('mainPlot');
                }
                
                // Resize curve plot if visible
                if (document.getElementById('curvePlot').style.display !== 'none' && 
                    document.getElementById('curveContainer').children.length > 0) {
                    Plotly.Plots.resize('curveContainer');
                }
            }, 100); // Debounce resize calls
        }

        // Add resize event listener
        window.addEventListener('resize', handleResize);

        // Also handle when sidebar collapses on mobile
        window.addEventListener('orientationchange', function() {
            setTimeout(handleResize, 500); // Delay for orientation change completion
        });

        // Intersection Observer to handle container size changes
        if (typeof ResizeObserver !== 'undefined') {
            const plotObserver = new ResizeObserver(function(entries) {
                for (let entry of entries) {
                    if (entry.target.id === 'plotArea' || entry.target.id === 'curvePlot') {
                        handleResize();
                    }
                }
            });

            // Observe plot containers
            plotObserver.observe(document.getElementById('plotArea'));
            plotObserver.observe(document.getElementById('curvePlot'));
        }
    </script>
</body>
</html>